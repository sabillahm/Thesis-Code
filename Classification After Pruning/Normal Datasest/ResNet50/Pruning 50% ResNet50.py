# -*- coding: utf-8 -*-
"""1 iterasi - Pruning ResNet 50% Percobaan 6 Fix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JEmQbXl06nOS9bS-5AY1IM-G2N07Eo80

# Cell 1: Import Libraries and Setup Device
'''
This cell imports all the necessary libraries and sets up the device for GPU computation if available.
We are using PyTorch for deep learning, OpenCV for image processing, and Matplotlib/Seaborn for visualization.
'''
"""

import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, Dataset
from torchvision import models, transforms
import cv2
from torchvision.transforms import v2
import matplotlib.pyplot as plt
import matplotlib.patheffects as path_effects
from tqdm import tqdm
import os
import numpy as np
import time
from sklearn.metrics import precision_score, recall_score, f1_score, confusion_matrix
import seaborn as sns

# Cek apakah kode dijalankan di Google Colab
IN_COLAB = 'google.colab' in str(get_ipython())

# Cek apakah GPU tersedia, jika tidak gunakan CPU
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(f'Using device: {device}')

# Mount Google Drive jika menggunakan Google Colab
if IN_COLAB:
    from google.colab import drive
    drive.mount('/content/drive')

"""# Cell 2: Define Data Loading and Preprocessing Functions
'''
This cell contains functions to load and preprocess images from the dataset.
The `load_data` function loads images from the specified directory and assigns labels based on the folder structure.
The `preprocess_image` function applies CLAHE and unsharp masking to enhance image quality.
The `CustomDataset` class integrates these functions and prepares the dataset for use in PyTorch.
'''
"""

def load_data(dataset_path, subset):
    images = []
    labels = []

    # Tentukan label sesuai dengan subset

    label_names = ['adenocarcinoma', 'large.cell.carcinoma', 'normal', 'squamous.cell.carcinoma']



    # Pemetaan nama label ke indeks
    label_map = {name: idx for idx, name in enumerate(label_names)}

    subset_path = os.path.join(dataset_path, subset)
    for label_name in label_names:
        image_dir = os.path.join(subset_path, label_name)
        if not os.path.exists(image_dir):
            raise FileNotFoundError(f"Directory not found: {image_dir}")
        for file_name in os.listdir(image_dir):
            if file_name.endswith('.png'):  # Cek jika file adalah gambar PNG
                image_path = os.path.join(image_dir, file_name)
                image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
                if image is None:
                    print(f"Warning: Unable to load image {image_path}")
                    continue
                images.append(image)
                labels.append(label_map[label_name])
                print(f"Loaded image {image_path}")
    return images, labels

def preprocess_image(image):
    if image is None or image.size == 0:
        raise ValueError("Empty image provided for preprocessing")

    # Terapkan CLAHE untuk meningkatkan kontras
    #clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    clahe = cv2.createCLAHE(clipLimit=2.5, tileGridSize=(10, 10))

    clahe_image = clahe.apply(image)

    # Terapkan Gaussian Blur untuk menghaluskan gambar
    #gaussian = cv2.GaussianBlur(image, (9, 9), 10.0)
    # Terapkan Unsharp Masking untuk meningkatkan ketajaman gambar
    #unsharp_image = cv2.addWeighted(clahe_image, 1.5, gaussian, -0.5, 0, clahe_image)
    #unsharp_image = cv2.addWeighted(gaussian, 1.5, gaussian, -0.5, 0)

    return clahe_image

class CustomDataset(Dataset):
    def __init__(self, images, labels, transform=None):
        self.images = images
        self.labels = labels
        self.transform = transform

    def __len__(self):
        return len(self.images)

    def __getitem__(self, idx):
        image = self.images[idx]
        label = self.labels[idx]
        try:
            # Proses gambar
            image = preprocess_image(image)
        except ValueError as e:
            print(f"Error preprocessing image at index {idx}: {e}")
            plt.imshow(image, cmap='gray')
            plt.title(f"Label: {label}")
            plt.show()
            raise e
        # Terapkan transformasi jika ada
        if self.transform:
            image = self.transform(image)
        if image.dim() == 2:  # Pastikan gambar memiliki 3 dimensi
            image = image.unsqueeze(0)
        return image, label

"""# Cell 3: Load and Transform Data
'''
This cell loads the data and applies the necessary transformations.
The dataset is divided into training, validation, and test sets.
Each image is transformed into a 224x224 size tensor suitable for input to the VGG-16 model.
'''
"""

# Mengatur path dataset, disesuaikan untuk Google Colab atau Jupyter Notebook
dataset_path = '/content/drive/MyDrive/Chest-CT-Data'

# Load data
train_images, train_labels = load_data(dataset_path, 'train')
valid_images, valid_labels = load_data(dataset_path, 'valid')
test_images, test_labels = load_data(dataset_path, 'test')

print(f"Loaded {len(train_images)} training images with {len(train_labels)} labels")
print(f"Loaded {len(valid_images)} validation images with {len(valid_labels)} labels")
print(f"Loaded {len(test_images)} test images with {len(test_labels)} labels")

# Transformasi data untuk persiapan training, validation, dan testing
transform = transforms.Compose([
    transforms.ToPILImage(),             # Ubah dari array NumPy ke gambar PIL
    transforms.Resize((224, 224)),       # Ubah ukuran gambar menjadi 224x224
    #v2.RandomHorizontalFlip(),           # Randomly flip the image horizontally
   # v2.RandomRotation(15),                # Randomly rotate the image by up to 15 degrees
    transforms.ToTensor(),               # Ubah gambar menjadi Tensor and normalize to [0, 1]
])

# Membuat dataset dan data loader untuk training, validation, dan testing
train_dataset = CustomDataset(train_images, train_labels, transform=transform)
valid_dataset = CustomDataset(valid_images, valid_labels, transform=transform)
test_dataset = CustomDataset(test_images, test_labels, transform=transform)

train_loader = DataLoader(train_dataset, batch_size=8, shuffle=True)  # DataLoader untuk training
valid_loader = DataLoader(valid_dataset, batch_size=8, shuffle=False) # DataLoader untuk validasi
test_loader = DataLoader(test_dataset, batch_size=8, shuffle=False)   # DataLoader untuk testing

"""## Pruning"""

# Prune a convolutional layer based on L2 norm
def prune_conv_layer(layer, prune_ratio, in_channels=None):
    out_channels = layer.out_channels
    num_keep = max(1, int(out_channels * (1 - prune_ratio)))

    weight = layer.weight.data.cpu()
    l2_norm = torch.norm(weight.view(weight.size(0), -1), p=2, dim=1)
    top_indices = torch.argsort(l2_norm, descending=True)[:num_keep]

    mask = torch.zeros(out_channels, device=weight.device)
    mask[top_indices] = 1

    layer.weight.data = layer.weight.data[top_indices]
    if layer.bias is not None:
        layer.bias.data = layer.bias.data[top_indices]

    layer.out_channels = num_keep

    if in_channels is not None:
        layer.weight.data = layer.weight.data[:, :in_channels]
        layer.in_channels = in_channels

    return mask, num_keep

# Prune a batch normalization layer
def prune_bn_layer(layer, mask):
    layer.weight.data = layer.weight.data[mask.bool()]
    layer.bias.data = layer.bias.data[mask.bool()]
    layer.running_mean = layer.running_mean[mask.bool()]
    layer.running_var = layer.running_var[mask.bool()]
    layer.num_features = int(mask.sum().item())

# Prune bottleneck block in ResNet
def prune_bottleneck(bottleneck, prune_ratio, in_channels):
    # Prune conv1
    mask1, out1 = prune_conv_layer(bottleneck.conv1, prune_ratio, in_channels)
    prune_bn_layer(bottleneck.bn1, mask1)

    # Prune conv2
    mask2, out2 = prune_conv_layer(bottleneck.conv2, prune_ratio, out1)
    prune_bn_layer(bottleneck.bn2, mask2)

    # Prune conv3
    mask3, out3 = prune_conv_layer(bottleneck.conv3, prune_ratio, out2)
    prune_bn_layer(bottleneck.bn3, mask3)

    # Handle downsample if it exists
    if bottleneck.downsample is not None:
        mask_down, _ = prune_conv_layer(bottleneck.downsample[0], prune_ratio, in_channels)
        prune_bn_layer(bottleneck.downsample[1], mask_down)

    return out3

# Prune each layer in ResNet
def prune_resnet_layer(layer, prune_ratio, in_channels):
    for bottleneck in layer:
        out_channels = prune_bottleneck(bottleneck, prune_ratio, in_channels)
        in_channels = out_channels
    return out_channels

# Prune the entire model
def prune_model_resnet(model, prune_ratio):
    in_channels = 3  # Initial input channels for ResNet
    mask, out_channels = prune_conv_layer(model.features[0], prune_ratio, in_channels)
    prune_bn_layer(model.features[1], mask)

    # Prune ResNet layers (layer1, layer2, layer3, layer4)
    for i in range(4, 8):
        out_channels = prune_resnet_layer(model.features[i], prune_ratio, out_channels)

    # Adjust the classifier input size based on pruned features
    with torch.no_grad():
        # Create a dummy input to get the output size of the features
        dummy_input = torch.randn(1, 3, 224, 224).to(next(model.parameters()).device)
        features_output = model.features(dummy_input)
        flattened_size = features_output.view(features_output.size(0), -1).size(1)

    # Update the Linear layer in the classifier to match the pruned model
    model.classifier = nn.Sequential(
        nn.Flatten(),
        nn.Linear(flattened_size, 512),  # Adjust input size to match the pruned model's output
        nn.ReLU(),
        nn.Dropout(0.4),
        nn.Linear(512, model.classifier[-1].out_features)
    )

    print(f"Adjusted classifier input size to {flattened_size}")
    return model

# Load and prune the model with adjustment to the classifier
def load_and_prune_model_resnet(model_path, prune_ratio):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model = Resnet50()
    model.load_state_dict(torch.load(model_path, map_location=device))
    print("Original model loaded.")

    # Prune the model and adjust the classifier
    pruned_model = prune_model_resnet(model, prune_ratio).to(device)

    return pruned_model

def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)
def calculate_model_size(model):
    """
    Calculate the size of the model in megabytes (MB).

    Args:
    - model: The model (before or after pruning).

    Returns:
    - size_in_mb: The size of the model in MB.
    """
    param_size = sum(param.numel() * param.element_size() for param in model.parameters())
    buffer_size = sum(buffer.numel() * buffer.element_size() for buffer in model.buffers())
    size_in_bytes = param_size + buffer_size
    size_in_mb = size_in_bytes / 1024**2  # Convert bytes to megabytes (MB)
    return size_in_mb

# Fungsi untuk memverifikasi pruning model
def verify_pruned_model(model, original_model):
    def calculate_num_params(model):
        return sum(p.numel() for p in model.parameters())

    # Calculate the model sizes
    original_size = calculate_model_size(original_model)
    pruned_size = calculate_model_size(model)
    print(f"Original model size: {original_size:.2f} MB")
    print(f"Pruned model size: {pruned_size:.2f} MB")
    print(f"Size reduction: {original_size - pruned_size:.2f} MB ({(original_size - pruned_size) / original_size * 100:.2f}%)")

    original_params = calculate_num_params(original_model)
    pruned_params = calculate_num_params(model)
    print(f"Original model parameters: {original_params}")
    print(f"Pruned model parameters: {pruned_params}")

    print("\nLayer-wise dimension comparison:")
    for (orig_name, orig_module), (pruned_name, pruned_module) in zip(original_model.features.named_modules(), model.features.named_modules()):
        if isinstance(orig_module, nn.Conv2d) and isinstance(pruned_module, nn.Conv2d):
            print(f"Layer: {orig_name}")
            print(f"  - Original shape: {orig_module.weight.shape}")
            print(f"  - Pruned shape: {pruned_module.weight.shape}")

from torchvision.models import resnet50, ResNet50_Weights
import copy

# Custom ResNet50 Class
class Resnet50(nn.Module):
    def __init__(self):
        super(Resnet50, self).__init__()
        resnet_model = resnet50(weights=ResNet50_Weights.IMAGENET1K_V1)
        self.features = nn.Sequential(*list(resnet_model.children())[:-1])
        self.classifier = nn.Sequential(
            nn.Flatten(),
            nn.Linear(2048, 512),
            nn.ReLU(),
            nn.Dropout(0.4),
            nn.Linear(512, 4)
        )

    def forward(self, input):
        x = self.features(input)
        x = self.classifier(x)
        return x

# Load model ResNet50 pretrained
model_resnet = Resnet50()
resnet_path = '/content/drive/MyDrive/best-model-resnet-clahe-0,001-8-70.pth'
model_resnet.load_state_dict(torch.load(resnet_path, map_location=device))

# Buat salinan model asli
resnet_model_copy = copy.deepcopy(model_resnet)

# Prune model dengan pruning ratio tertentu
pruning_amount = 0.5  # Contoh: prune 50% filter
pruned_model_resnet = load_and_prune_model_resnet(resnet_path, pruning_amount)

# Model sekarang sudah di-prune dan siap untuk digunakan
verify_pruned_model(pruned_model_resnet, resnet_model_copy)
torch.save(pruned_model_resnet.state_dict(), '/content/drive/MyDrive/Best-pruning-model/pruned-resnet-50.pth')

import time  # Import modul time

# Define the optimizer and loss function
optimizer = optim.SGD(pruned_model_resnet.parameters(), lr=0.001, momentum=0.8)
criterion = nn.CrossEntropyLoss()

# Function to calculate metrics (accuracy, precision, recall, F1-score)
def calculate_metrics(predictions, labels):
    preds = torch.argmax(predictions, dim=1).cpu().numpy()
    labels = labels.cpu().numpy()

    accuracy = (preds == labels).mean() * 100
    precision = precision_score(labels, preds, average='weighted', zero_division=1)
    recall = recall_score(labels, preds, average='weighted', zero_division=1)
    f1 = f1_score(labels, preds, average='weighted', zero_division=1)

    return accuracy, precision, recall, f1

# Function to train and evaluate the model
def train_and_evaluate(pruned_model, train_loader, valid_loader,  num_epochs=100):
    train_losses = []
    valid_losses = []
    train_accuracies = []
    valid_accuracies = []
    all_train_precisions = []
    all_train_recalls = []
    all_train_f1s = []
    all_valid_precisions = []
    all_valid_recalls = []
    all_valid_f1s = []

    best_valid_loss = float('inf')

    # Variable to accumulate total training and validation time
    total_train_validation_time = 0

    for epoch in range(1, num_epochs + 1):
        print(f'Epoch {epoch}/{num_epochs}')

        # Start timer for both training and validation
        start_epoch_time = time.time()

        # Training
        pruned_model_resnet.train()
        train_loss = 0
        all_train_preds = []
        all_train_labels = []
        for images, labels in tqdm(train_loader, desc='Training'):
            images, labels = images.to(device), labels.to(device)

            # Convert grayscale images to 3 channels
            if images.size(1) == 1:  # If single channel
                images = images.repeat(1, 3, 1, 1)  # Repeat the channel dimension 3 times

            optimizer.zero_grad()
            outputs = pruned_model_resnet(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            train_loss += loss.item()

            all_train_preds.append(outputs)
            all_train_labels.append(labels)

        train_loss /= len(train_loader)
        train_losses.append(train_loss)
        train_accuracy, train_precision, train_recall, train_f1 = calculate_metrics(torch.cat(all_train_preds), torch.cat(all_train_labels))
        train_accuracies.append(train_accuracy)
        all_train_precisions.append(train_precision) # Store train_precision
        all_train_recalls.append(train_recall)       # Store train_recall
        all_train_f1s.append(train_f1)             # Store train_f1

        print(f"Training Loss: {train_loss:.4f}, Accuracy: {train_accuracy:.2f}%, Precision: {train_precision:.4f}, Recall: {train_recall:.4f}, F1-Score: {train_f1:.4f}")

        # Validation
        pruned_model_resnet.eval()
        valid_loss = 0
        all_valid_preds = []
        all_valid_labels = []
        with torch.no_grad():
            for images, labels in tqdm(valid_loader, desc='Validation'):
                images, labels = images.to(device), labels.to(device)

                # Convert grayscale images to 3 channels
                if images.size(1) == 1:
                    images = images.repeat(1, 3, 1, 1)

                outputs = pruned_model_resnet(images)
                loss = criterion(outputs, labels)
                valid_loss += loss.item()

                all_valid_preds.append(outputs)
                all_valid_labels.append(labels)

        valid_loss /= len(valid_loader)
        valid_losses.append(valid_loss)
        valid_accuracy, valid_precision, valid_recall, valid_f1 = calculate_metrics(torch.cat(all_valid_preds), torch.cat(all_valid_labels))
        valid_accuracies.append(valid_accuracy)
        all_valid_precisions.append(valid_precision)  # Store valid_precision
        all_valid_recalls.append(valid_recall)        # Store valid_recall
        all_valid_f1s.append(valid_f1)

        print(f"Validation Loss: {valid_loss:.4f}, Accuracy: {valid_accuracy:.2f}%, Precision: {valid_precision:.4f}, Recall: {valid_recall:.4f}, F1-Score: {valid_f1:.4f}")

        # Save the best model based on validation loss
        if valid_loss < best_valid_loss:
            best_valid_loss = valid_loss
            torch.save(pruned_model_resnet.state_dict(), '/content/drive/MyDrive/Best-pruning-model/best-pruned-resnet-50.pth')
            print("New best model saved")

        # End timer for training and validation, and accumulate the time
        end_epoch_time = time.time()
        epoch_time = end_epoch_time - start_epoch_time
        total_train_validation_time += epoch_time
        #print(f"Epoch Time (Training + Validation): {epoch_time:.2f} seconds")

    # Print total training and validation time
    print(f"Total Training + Validation Time: {total_train_validation_time:.2f} seconds")

    return train_losses, valid_losses, train_accuracies, valid_accuracies, all_train_precisions, all_train_recalls, all_train_f1s, all_valid_precisions, all_valid_recalls, all_valid_f1s # Return the stored metrics

# Load Model Hasil Pruning
pruned_path_resnet = '/content/drive/MyDrive/Best-pruning-model/pruned-resnet-50.pth'
pruned_model_resnet.load_state_dict(torch.load(pruned_path_resnet, map_location=device))
pruned_model_resnet = pruned_model_resnet.to(device)


# Fine-tuning model yang telah di-prune
num_epochs = 70  # Tentukan jumlah epoch untuk fine-tuning

# Training
train_losses, valid_losses, train_accuracies, valid_accuracies, train_precisions, train_recalls, train_f1s, valid_precisions, valid_recalls, valid_f1s = train_and_evaluate(pruned_model_resnet, train_loader, valid_loader, num_epochs=num_epochs)

# Simpan model setelah fine-tuning
torch.save(pruned_model_resnet.state_dict(), '/content/drive/MyDrive/Best-pruning-model/fine_tuned_pruned_resnet-50.pth')

# Plot training and validation loss
plt.figure(figsize=(10, 5))
plt.plot(train_losses, label='Training Loss')
plt.plot(valid_losses, label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.title('Training and Validation Loss')
plt.show()

# Plot training and validation accuracy
plt.figure(figsize=(10, 5))
plt.plot(train_accuracies, label='Training Accuracy')
plt.plot(valid_accuracies, label='Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()
plt.title('Training and Validation Accuracy')
plt.show()

# Hitung rata-rata metrik setelah semua epoch
average_train_loss = np.mean(train_losses)
average_valid_loss = np.mean(valid_losses)
average_train_accuracy = np.mean(train_accuracies)
average_valid_accuracy = np.mean(valid_accuracies)
average_train_precision = np.mean(train_precisions) # Calculate mean from stored values
average_valid_precision = np.mean(valid_precisions) # Calculate mean from stored values
average_train_recall = np.mean(train_recalls)     # Calculate mean from stored values
average_valid_recall = np.mean(valid_recalls)     # Calculate mean from stored values
average_train_f1 = np.mean(train_f1s)           # Calculate mean from stored values
average_valid_f1 = np.mean(valid_f1s)           # Calculate mean from stored values



# Display results training
print('--------------')
print(f'Training Accuracy: {average_train_accuracy:.2f}%')
print(f'Training Loss: {average_train_loss:.4f}')
print(f'Training Precision: {average_train_precision:.4f}')
print(f'Training Recall: {average_train_recall:.4f}')
print(f'Training F1-Score: {average_train_f1:.4f}')


# Display results validasi
print('--------------')
print(f'Validation Accuracy: {average_valid_accuracy:.2f}%')
print(f'Validation Loss: {average_valid_loss:.4f}')
print(f'Validation Precision: {average_valid_precision:.4f}')
print(f'Validation Recall: {average_valid_recall:.4f}')
print(f'Validation F1-Score: {average_valid_f1:.4f}')

def debug_pruned_weights(model):
    """
    Print out the number of filters and weights in each layer to ensure pruning is correctly applied.
    """
    for name, module in model.named_modules():
        if isinstance(module, nn.Conv2d):
            print(f"Layer: {name}, Weights Shape: {module.weight.shape}")

# Periksa model setelah pruning
debug_pruned_weights(pruned_model_resnet)

# Test the model

pruned_model_resnet.load_state_dict(torch.load('/content/drive/MyDrive/Best-pruning-model/fine_tuned_pruned_resnet-50.pth'))
pruned_model_resnet.eval()

# Start timer for testing
start_test_time = time.time()

test_loss = 0
all_test_preds = []
all_test_labels = []
correct = 0
total = 0
with torch.no_grad():
  for images, labels in tqdm(test_loader, desc='Testing'):
    images, labels = images.to(device), labels.to(device)

    # Convert grayscale images to 3 channels
    if images.size(1) == 1:
      images = images.repeat(1, 3, 1, 1)

    outputs = pruned_model_resnet(images)
    loss = criterion(outputs, labels)
    test_loss += loss.item()

    all_test_preds.append(outputs)
    all_test_labels.append(labels)

    _, predicted = torch.max(outputs.data, 1)
    total += labels.size(0)
    correct += (predicted == labels).sum().item()

test_loss /= len(test_loader)
test_accuracy, test_precision, test_recall, test_f1 = calculate_metrics(torch.cat(all_test_preds), torch.cat(all_test_labels))
print("\n---------------------------------------------------------------------------------------------\n")
print(f"Test Loss: {test_loss:.4f}, Accuracy: {test_accuracy:.2f}%, Precision: {test_precision:.4f}, Recall: {test_recall:.4f}, F1-Score: {test_f1:.4f}")

# End timer for testing and print the total time
end_test_time = time.time()
total_testing_time = end_test_time - start_test_time
print(f"Total Testing Time: {total_testing_time:.2f} seconds")

# Path dinamis untuk memuat model terbaik
#best_model_file = '/content/drive/MyDrive/Chest-CT-Data/best-model-vgg-clahe-0,001.pth' if IN_COLAB else 'best-model.pth'
# Start testing time
testing_start_time = time.time()

# Load the best model
pruned_model_resnet.load_state_dict(torch.load('/content/drive/MyDrive/Best-pruning-model/fine_tuned_pruned_resnet-50.pth'))
pruned_model_resnet.eval()

# Define class labels corresponding to the numerical labels
class_labels = [
    'Adenocarcinoma',
    'Large Cell Carcinoma',
    'Normal',
    'Squamous Cell Carcinoma'
]

predicted_probabilities = []
true_labels = []

test_loader_tqdm = tqdm(test_loader, desc="Testing")
with torch.no_grad():
    for images, labels in test_loader_tqdm:
        images, labels = images.to(device), labels.to(device)
        if images.dim() == 3:
            images = images.unsqueeze(1)
        images = images.repeat(1, 3, 1, 1)
        outputs = pruned_model_resnet(images)
        loss = criterion(outputs, labels)
        probabilities = nn.functional.softmax(outputs, dim=1)
        predicted_probabilities.append(probabilities)
        true_labels.append(labels)
        #test_loader_tqdm.set_postfix({"Batch Size": len(labels)})

# End testing time
total_testing_time = time.time() - testing_start_time
print(f"Total testing time: {total_testing_time:.2f} seconds")

# Calculate evaluation metrics
predicted_probabilities = torch.cat(predicted_probabilities)
true_labels = torch.cat(true_labels)
predicted_labels = torch.argmax(predicted_probabilities, dim=1)

accuracy = (predicted_labels == true_labels).float().mean().item()
precision = precision_score(true_labels.cpu(), predicted_labels.cpu(), average='weighted')
recall = recall_score(true_labels.cpu(), predicted_labels.cpu(), average='weighted')
f1 = f1_score(true_labels.cpu(), predicted_labels.cpu(), average='weighted')
conf_matrix = confusion_matrix(true_labels.cpu(), predicted_labels.cpu())

# Display results
print(f'Test Accuracy: {accuracy * 100:.2f}%')
print(f'Test Loss: {loss:.4f}')
print(f'Precision: {precision:.4f}')
print(f'Recall: {recall:.4f}')
print(f'F1-Score: {f1:.4f}')
print(f'Confusion Matrix:\n{conf_matrix}')

# Plot confusion matrix using Matplotlib
fig, ax = plt.subplots(figsize=(12, 9))
cax = ax.matshow(conf_matrix, cmap='Blues')

# Menampilkan angka pada setiap sel dengan outline putih
for (i, j), val in np.ndenumerate(conf_matrix):
    text = ax.text(j, i, f'{val}', ha='center', va='center', color='black', fontsize=20, fontweight='bold')

    # Menambahkan outline putih di sekitar angka
    text.set_path_effects([path_effects.Stroke(linewidth=3, foreground='white'),
                           path_effects.Normal()])

fig.colorbar(cax)

# Set ticks dan ticklabels
ax.set_xticks(np.arange(len(class_labels)))
ax.set_yticks(np.arange(len(class_labels)))
ax.set_xticklabels(class_labels)
ax.set_yticklabels(class_labels)

plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.title('Confusion Matrix')
plt.show()


# Total time for the whole process
#total_process_time = total_training_time + total_testing_time
#print(f"Total process time (training + testing): {total_process_time:.2f} seconds")

"""perhitungan benar

![image.png](data:image/png;base64,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u3eYZZZZsjlqDn6Lq666athvv/3CRx99lE0N4a233grbbLNN2HnnncPPP/+cTR2BbGOfPn3i/Ndeey2bGsKwYcPi53Ah47PPPsumtr033ngjrLbaauGuu+4KSyyxRFhqqaXieqy55prh/vvvz5b6yy233BLuueeecMQRR4QpppgimypJktQ2OnQA9vXXX4dDDz00zDfffOE///lPNnXUoQGXbygSDN57773ZK3VkY489djj88MPDd999F6699tqYBVHzkBnaa6+9wnPPPRdfE1Dx/O677w4rr7xynHb11VeHiy66KD5HqVQK/fv3DzfddFN8zXKPPPJIePzxx8MWW2wRpz366KPh+OOPjxnmpnj99dfjvxNPPHE4/fTTw6BBg+o8DjrooPB///d/cRm+/4ILLoi/26OOOircdtttMRPKtD///DNcdtlldb73ww8/jOvLuq200krZVEmSpLbTYQMwxkdxpZoG1njjjRf233//MP7442dzi0fj8/bbb4/PZ5111jDDDDPE53fccUf49ttv43NpdEbQdOedd8bnBF+nnHJK/C3QVe/iiy+O2SVceuml4fPPP4/P33zzzTB48OD4fNlll43LzTvvvHHs42mnnRY233zzOO+6666LyzYHn0G3Qrol5x9LL710DLhBwP3UU0+FKaecMs4jAwr+tkwzzTTh6aefjhd6QCBG90YwXnCcccaJzyVJktpSh86AEeSccMIJsXsT3YVGJboapu6HG220UeyGheeffz424qTRHec/GSWCm0033bROgEJGkfGRIJB64YUX4nP+/eabb+Jzskr5zCPvp2sxn0egdN9992Vz6kf3RrouYqyxxqoEVPX59ddf4zguvosLOQnvHXPMMWPQRSYMbB/B4yGHHFK5wCJJktTWOmwANtVUU8Xs0i677BImmGCCbOqoQ1dDuhzS7Ykr6QzSH3fccWODlPXk3/rQZYqgrVu3brEBOv3008er/zQOG8Jn0l2LblupeAD7pW/fvnEsTl51RUXG3VD0gOIITOP9ZC2q35dQJIHsBuNx0nryILtBd62GCiX88MMP4dRTTw3zzz9/5X18BtkN1ivh+dFHH11nOdaL7SO7kkcRBbaDZdguxhudccYZMZPBNMboJOwngmD2MfsnfTZFIq688sq4TPXn5dcrX9SBLCf7iH2c9gPFIsjQ1FdgIm1XvigF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JElSQQzAJEmSJKkgBmCSJEmSVBADMEmSJEkqiAGYJEmSJBXEAEySJEmSCmIAJkmSJEkFMQCTJEmSpIIYgEmSJElSQQzAJEmSJKkgBmCSJEmSVBADMEmSJEkqiAGYJEmSJBXEAEySJEmSCmIAJkmSJEkFMQCTJEmSpIIYgEmSJElSQQzAJEmSJKkgBmCSJEmSVBADMEmSJEkqiAGYJEmSJBXEAEySJEmSCmIAJkmSJEkFMQCTJEmSpIIYgEmSJElSQQzAJEmSJKkgBmCSJEmSVBADMHU4P/30U1h99dVD165dw1xzzRU+/fTTbE4IAwcOjNN53H777dnU0ddLL70UZp555jDJJJOEm2++OZsqSZKkzqpDB2Cvv/562GijjUK3bt1ig5t/ec30ItDwJwDguwkICAw0Avvm1FNPDYsvvngMDlJQNNVUU4Xll1++wwZHpVIpPP/886Ffv36hR48elfXmMcsss4Q+ffqE999/P1t61LvnnnvCV199Ff78888wZMiQbKpaoqV/T/74449w5513hpVXXrnOuT7//POHp59+OluqcZx7HM8VVlih8hmcg+edd1745ZdfsqX+8ttvv4Xzzz+/cp6yvgceeGD4+eefsyXquv/++8Nkk00WLrroomyKJEnqiDpsAHbhhReGxRZbLDZ85plnnrDllluGmWaaKb5ecsklwy233JItqSLRUDz++OPDHHPMEQ4//PDwyiuvxOAgoXFIo/Smm27KpnQcH3/8cVhnnXVC7969w8UXXxyGDRuWzRnhyy+/DNdff3147bXXsimjHo1+MmDjjz9+WGuttbKpag4CnyuuuKLy94TABvzLa6YT6LBctW+++SZsvfXWMVB7/PHH65zr7733Xvjiiy+yVw3juw499NCw/vrrh6eeeiqbGuI5uN9++4WNN944fP/999nUEet8xBFHhH333Te+l/dNPPHE4eyzzw7bbLPNSAHb119/HY488siw9NJLh0022SSbKkmSOqIOG4DRSKGhTGP4wQcfDGeddVZs2J9zzjnxinT//v2b3PhR26CBuNNOO4Vjjz02mxLC1FNPHbNGBMwENXvuuWdYdtllwwQTTJAt0TG8+OKLYaWVVgoPPPBANiWEBRZYIGYUBg0aFM4888y4HXPOOWcYa6yxsiVGvbnnnju88MIL4bPPPgtrrrlmNlXNQYaL4IfgiSDmmmuuCR9++GG49tprY1aJ6Ycddljcz3lkvAl20sUesuB33313ePPNN8Nzzz0XM8DTTjttnNeYG264IZxxxhnxOReQHnnkkfg3js8E5+Xpp59eCQL5u3fZZZeFWWedNf79+/e//x3//i244ILhvvvui11TE95zySWXhHfeeSdeFJlwwgmzOZIkqUMq/+fdIZUbOqWff/45e/UXpq277rqlSSedtPToo49mU9vHsGHDSuUGealLly6l1VZbrfTjjz9mc/5+yo3U0v777x/3BY+ZZpqpVG4Ixultjf3M/uZ72P8ch2TAgAGVdRgyZEg2tWGff/55aZFFFqm8b6211ioNHTo0m6vRXTnwqRz7yy+/PJs6wuDBgyvzWC7vwgsvjNPLQVvpuuuua/G5/t1335WWW265+Fmch5yPyVdffVVaZpll4ry55pqr9PHHH8fpV199dZx25JFHxtfJSSedNNK6Pv/886XpppuudPLJJ7fL71GSJLWtDpsBW3HFFWO3q2pM6969e/j999/Dt99+m01Ve+NqfRpbQhah3CAN5UZlGGOMMeK0jozsXOpWSHau3AhvcuZCnV/qcsjfDjKKeYyvSn9n0nIoB0kx244tttgidl1t6blON13GHWLdddcNU0wxRXwOxmzx2fjoo4/isqC7LMrBVvw3SdnZtK50RaQ3AJkyMrid4fcoSdLfXaetgkhDY7zxxstedRxvvfXWSAUe0mD/t99+O1tqhOoiH3QzO+CAA+JA/xlmmKFON6PqAgLTTz99OO2002LBiIYKhZSD7NjdKV9AgEIZffv2rTTyGsNn0G1r+PDh8TXdtXr16hWfNwffx/fy/awH68N6sX58R3ugIc24LhA4Mn6N726qVIBhvfXWq6w3Dxq8jNGpLohA8ZG0DBUbOeap6ALjePLL//DDD7EbG8Uc0ns4vptvvnml8mP15yXV5w7dQ+nmxnFhGvuW7nP1HeP8dqVziseiiy4aLrjggpHGGFVXpvzkk09iVcb0fXwG5y7bhHSs02fze6AbHd9brTm/GYIUxjmxfXRLbsp5M++888a/F2xTCnASPj9tK7+phOVYL963wQYbhLHHHjub03wE/1ww4rMYb1atZ8+elcDp5Zdfjv+OM8448d/q/ZVepwsIdI+ksAfnIsGcJEnq+DpdAEaD+plnnoljj6ha15EQMC2zzDIjFXjgajWN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SZIkSQUxAJMkSZKkghiASZIkSVJBDMAkSZIkqSAGYJIkSZJUEAMwSZIkSSqIAZgkSZIkFcQATJIkSZIKYgAmSZIkSQUxAJMkSZKkghiASZIkSVJBDMAkSZIkqSAGYJIkSZJUEAMwSZIkSSqIAZgkSZIkFcQATJIkSZIKYgAmSZIkSQUxAJMkSZKkghiASZIkSVJBDMAkSZIkqSAGYJIkSZJUEAMwSZIkSSqIAZgkSZIkFcQATJIkSZIKYgAmSZIkSQUxAJMkSZKkghiAqU389NNPYfXVVw9du3YNc801V/j000+zOZIkSZKSDhuA/fDDD+HUU08Nc889d2zU85h11lnD4YcfHucVgSCCYCJ9/y677BJ+++23bO7Ibr/99sqyAwcOzKaqNX755Zdw6KGHxn3K/q3lq6++CgcffHCYfvrp43KTTDJJ2HDDDcPrr7+eLTGyn3/+OZx22mmhR48elWO2wgorhEceeSSUSqVsqaZh+XvuuSe+P30Wn3veeefF9a/GOXT++edXvrtbt27hwAMPjOtUy/333x8mm2yycNFFF2VTJEmS1Fl12ABs3333jcEWNt1007DGGmvELAtBWe/evcNHH30U5xXpqquuCkOGDMleqT398ccf4bbbbguLLbZYOP3007OpI3vxxRfD0ksvHc4888zw3XffxWl//vlnuOuuu+J7b7755jgt7+OPPw6rrbZaOOyww8KwYcOyqSE89dRTcTqBWVODMIIpAsT1118/vj/hc/fbb7+w8cYbh++//z6bOiJYO+KII+L5zXt538QTTxzOPvvssM0224wUsH399dfhyCOPjNu4ySabZFMlSZLUWXXYAGy22WYLjz76aHjllVdiJoHg57333gtbbbVVeOeddxpslLcXGvZHH310bMCrfRCAnHHGGWH22WePgTfHvD4EJ3vssUcYOnRoGGecccLJJ58cXnvttXi+jD/++PF4EQS9++672TtGBExky5577rn4eq+99orn2A033BCmm266OO2YY44Jjz32WHzeGN7H+mLJJZeMGTQCMbpj4oEHHojnagroWL/LLrssZnMffPDB8O9//zs8/fTTYcEFFwz33XdfeOmll+Jy4D2XXHJJPN+5GDHhhBNmcyRJktRZddgAjIbzPPPMk70agUb1tttuG/+l0UxGrCg08McYY4zw5ptv1mlQq22RxTrnnHPC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kiRJKogBmCRJkiQVxABMkiRJkgpiACZJkiRJBTEAkyRJkqSCGIBJkiRJUkEMwNQpvPTSS2HmmWcOk0wySbj55puzqXV99tlnoW/fvqFbt26ha9euYb755guff/55uP322+O06aefPjzzzDPZ0s3z008/hQ022CB+7h577BF+++23bI4kSZLUdIUGYL///nvYdtttYyOWx3rrrRd++eWXbK7awx9//BGeeOKJ0KdPnzDDDDNU9j2PueaaK/Tv3z/8+uuv2dId1z333BO++uqr8Oeff4YhQ4ZkU//y0UcfhVVXXTVceumlleCI843lb7rppjjtu+++C//973/jvOZ66623wsMPPxyfp3WRJEmSmqvQAGzo0KHhoYceyl6F+JzMhtrH999/HwOvlVZaKVx//fXh22+/zeaMwPF45JFHYpDW0a288soxAzb++OOHtdZaK5v6l9NPPz2888478fn2228fXnnllfDYY4+FqaaaKmyyySahS5cuYeqppw7LLrtsXKa5Zp999rDGGmuEMcYYI6y++uoxo5aw/55++unQr1+/sOWWW8ZsmSRJklTLGKWy7Hm7O//888O+++6bvRrhoIMOig+1LbI/++23X7joooviawKQ7bbbLiy44ILxNV588cXYRe+EE04IE044YTa18yHg2WijjWKGim6Gd999d5hmmmmyue3v008/Dcsvv3wMaJdaaqlw7bXXdur9KUmSpPZTWAaMroaMxcGss84au8PhjjvuGCkzo9YjGLj11lvj85lmmilmg4466qiw7rrrVh6HH354OPPMM0erYGHGGWcME088cfZKkiRJ6lgKC8Doapi6H5KtYLwOnn/++dh9S22LoJYuiJhuuunqdJmTJEmSNGoUFoDde++9Yfjw4TE7Qfbln//8Zxh33HEDPSDJguV7Qj755JNh8sknj4UiGFNDd7pq11xzTaWYBF0bEz6HcU2MGaJiHvMZB0R1vI8//jhbagS6jlGIgmUY10MVvQMOOCC+jwxdGp9G9o5uZXQzSxX2eMw999zxu2tVxKu1Hj169AjXXXddrMQ35ZRTxmk77bRT9o6/MKbohhtuCIsuumjlu8gakrH64YcfsqUaxlip8cYbLz5/++2347Y1hq587Ae+j/3C/nn99ddjsJzWg21mG+obN8b6sZ6sb3oP28H2NPSeU089Ncw///yV97CfN998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uWFVWnLJJePyvI/38zmnnnpqafjw4dlSzTNkyJD4eQsuuGDpwAMPLF177bWlG2+8sXTppZeWtt122/g9a621VqncUM3e0XGxjvvvv3/cL+XGY2n22WeP2zbnnHOW7rrrrtKff/6ZLVnb999/X9p3333j+3nMNtts8f1s/6effpot1Tx853XXXVeaZppp4rFiXVi3cgO3dN5555V+//33bMnOY+jQoaUddtihNPXUU5eee+65bGr92HebbbZZqWvXrqWZZ545Hheer7LKKqVyAz1bamTtue9auk4dEfuB3y3bwfnKv+yvmWaaqfTAAw9kSzWOvyFbbbVV/Az+LrQUv0N+R3zO9NNPX+rRo0f8PfXq1av0zDPPZEtJaogBmCS1ke+++y425mmMnH322ZUG5EsvvVSad955Y7Dz9NNPx2nVbrrppvi+3r17VxqIKZijodO3b98WBWEpAKvvscgii5TeeeedbOmOK+1bAtTXXnstmzoiqNprr71i43rgwIH1BmFsI9tK4/6aa66pHJtXX301NiD79OlT+u233+K0puK7+E724/bbb18JYtNxY5369evX4uC5KB9//HHp6quvLu29995xH6Vzg33VWAD24Ycflnr27BnP7fvuuy+b+tc5T5Dw7LPPZlP/0p77rqXr1BGxP/bcc8+4PzjPOd/B/tpyyy3jufv+++/HaY0ZPHhw5di2NADL/427/PLLK783gnaCWwLDm2++OU6TVD8DMElqAzQUCZJo3NRqzN99992xEbX22muXfvzxx2zqCARlNBa7detWeuKJJ7KpI9AAW3fddWOD57bbbsumNl19ARgNpUMOOaTSoGtLDz30UGmnnXYq/fLLL9mU1rvwwgtL888/f83sBft+5513jg1rAqpqqUFOQPHUU09lU0ulr776qrT44ovH/UH2ZdiwYdmcpiE44TO58v/ZZ59lU0fIH7d8ENBarPOmm27aaDa1OVg/tp8s6X777Vfadddd4z5pLADjHN9tt93ismSsqqVzfqONNor7I6+99l1r1qk1rrjiitKRRx6ZvWob+b8pJ598cp2LCwcddFCczqMpwRQXIFLGuKnvqWXAgAHx/fvss89IFzteeeWV+HeMIP7zzz/PpkqqxSIcktQGHnzwwXDppZfG56uuuupI47bKDdww9dRThwceeCA89thj2dQQykFKOOaYY+K4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fbYIvhgfdeGFF8bXOPLII2N3xPpwM2MeFMLgfS3JxOGMM84It99+exg8ePBI/9e0JgBjG8mM7b///rEgR3LRRRfFQI9/mY8PP/wwbLrppmHgwIExO6jWMwCTJEnS3x4BBoEWpd6rx0PRXKZQBUUt6MpHIYv6MlsEcuuuu24s9063QYp4tARZNNaDboPcwLkawRNVGRdeeOG4znQt5N5ejQVidD2kJD5OP/30SlaLbBsBI9UW77zzztCzZ884HYwR47PZHrWeY8AkSZL0t8YYJ4pcUIp+0UUXzab+hQzWcsstF7sljjvuuPHGywQstVB845VXXonPxxtvvPhvS9ANkMcmm2wS7ztW/SD4wlNPPRWDJaZRrbExZPd4D4VB8l0KKVH/1ltvxXWmImQeQR5j0X799ddsilrDAEySJEkdwt133x272rXFY+mll45juZqCrBBdDQlIGgqaKOzBzZTHHHPMeouFvPnmm5WbOM8666zx35Yg4OOzaj2ef/75GBSBf3nNdKo+NoTuhHSNJPjK38sM3377bczekUFLpfgTsl8EqVRVVOsZgEmSJKlDoHrhO++8M1LA0ZLHHXfcESaddNLskxtG4EWQQSDWlCzPVFNNVakmWI3sUnMQ2DCGiwxcPsAhEOR7aj3I1FH5EfzLa6Y31P2QbSP4ImBbe+21s6kaFQzAJEmS1CGQVZpiiilGCjha8mhOUQqCKTJOdC28/vrr45ivWuiGR7Zp8803j1m2WppTfIT7nVHmnUqL66yzTuzi2F7q63qYsM+6desWx7h9+umn2dQRCIopStKcfar6GYBJkiTpb48giBLzRx99dDj33HPrZKMIyAheuD8YY8QoVlEL48KoMNhU//vf/+oEO4z5agiFPRj7RVXEt99+O07jX14znft91ULXwxNOOCEcdthhI3U9TCaffPKw2GKLxUxZ6kIJnt977701x8apZQzAJEmS9LdHRotqgmussUY44IADwkwzzRS22WabWO59nnnmCSuuuGJYZpllapaET+gOSCYJFO5orAgHGaVdd901Fr2giAaZtYawfltttVUsgZ8CN/7lNdOHDBkSp+WlrocEV9ybrD5jjz122HLLLcOff/4Zg7mUBbzrrrvCJ598ElZeeeX4Wq1nGXpJkkYzdIE666yzwkILLRRWWmmlbKqkpqBpTJe7W2+9NVY0xOyzzx7WW2+9MN1008XXDSHbdM4558SAZ80116y3WEdR6FJ54oknxhsup3ub1YdtJ8ijmyL3B5tooonC1VdfHc4+++zYRVJtwwBMkqTRCP+t9+/fPza4GrtZrKTRH/cvY8zXkksumU1pHOXoBw0aFJ+TWSMAVdsxAJMkaTTy6KOPxgpnw4cPNwCTpA7IMWCSJI0mvv7663DwwQfH4EuS1DEZgEmSNBqgQ8sll1wSbzzLgH5JUsdkACZJ0mjgmWeeCZdeemkc+8W9fCRJHZMBmCRJnRxVDw8//PCwww47hPnnnz+bKknqiAzAJEnqxOh6SNloqpxtu+222VRJUkdlACZJUieWuh6SAeOmrpKkjs0ATJKkToquh0cffXTMfC244ILZVElSR2YAJklSJ0XmCwRgY4wxRnwuSerYDMAkSeqEXnjhhTj267DDDgtdu3bNpkqSOjoDMEmSOpmffvopjvnaeuutQ69evbKpkqTOwABMkqROZvDgweG7774La621Vvjss8/Cp59+Wnl88cUX4Y8//ojLEagx7fPPPw+//fZbnCZJGrXGKFG/VpIkdRo77bRTuOqqq7JXjRt//PHDnXfeGXr27JlNkSSNKgZgkiR1MmS/fvnll+xVXa+88krYbLPN4vz9998/bL/99mHMMccMk046abxXmCRp1LILoiRJnczEE08cpppqqpqPbt26ZUuFeF8wpnXv3t3gS5I6CAMwSZIkSSrIWP8qy55LkqROiO6GDzzwQHjppZfCPffcEx599NE4nXuDkfl67733whRTTBHHgkmSRi3HgEmS1MlR6XD55ZcPQ4cOzabUZREOSeo4DMAkSZIkqSCOAZMkSZKkghiASZIkSVJBDMAkSZIkqSAGYJIkSZJUEAMwSZIkSSqIAZgkSZIkFcQATJIkSZIKYgAmSZIkSQUxAJMkSZKkghiASZIkSVJBDMAkSZIkqSAGYJIkSZJUEAMwSZIkSSqIAZgkSZIkFcQATJIkSZIKYgAmSZIkSQUxAJMkSZKkghiASZIkSVJBDMAkSZIkqSAGYJIkSZJUEAMwSZIkSSqIAZgkSZIkFcQATJIkSZIKYgAmSZIkSQUxAJMkSZKkghiASZIkSVJBDMAkSZIkqSAGYJIkSZJUiBD+H+5b9iiy9vJXAAAAAElFTkSuQmCC)
"""



# Test the model

pruned_model_resnet.load_state_dict(torch.load('/content/drive/MyDrive/Best-pruning-model/best-pruned-resnet-50.pth'))
pruned_model_resnet.eval()

test_loss = 0
all_test_preds = []
all_test_labels = []
correct = 0
total = 0
with torch.no_grad():
  for images, labels in tqdm(test_loader, desc='Testing'):
    images, labels = images.to(device), labels.to(device)

    # Convert grayscale images to 3 channels
    if images.size(1) == 1:
      images = images.repeat(1, 3, 1, 1)

    outputs = pruned_model_resnet(images)
    loss = criterion(outputs, labels)
    test_loss += loss.item()

    all_test_preds.append(outputs)
    all_test_labels.append(labels)

    _, predicted = torch.max(outputs.data, 1)
    total += labels.size(0)
    correct += (predicted == labels).sum().item()

test_loss /= len(test_loader)
test_accuracy, test_precision, test_recall, test_f1 = calculate_metrics(torch.cat(all_test_preds), torch.cat(all_test_labels))
print("\n---------------------------------------------------------------------------------------------\n")
print(f"Test Loss: {test_loss:.4f}, Accuracy: {test_accuracy:.2f}%, Precision: {test_precision:.4f}, Recall: {test_recall:.4f}, F1-Score: {test_f1:.4f}")

