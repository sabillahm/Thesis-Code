# -*- coding: utf-8 -*-
"""1 Iterasi-RESNET50-CLAHE-0,001-8-BS-70-Versi1-Original.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eKGw-NUc6OZfpXy0REC7jJ-2XObke5d7

# Cell 1: Import Libraries and Setup Device
'''
This cell imports all the necessary libraries and sets up the device for GPU computation if available.
We are using PyTorch for deep learning, OpenCV for image processing, and Matplotlib/Seaborn for visualization.
'''
"""

import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, Dataset
from torchvision import models, transforms
import cv2
from torchvision.transforms import v2
import matplotlib.pyplot as plt
import matplotlib.patheffects as path_effects
from tqdm import tqdm
import os
import numpy as np
import time
from sklearn.metrics import precision_score, recall_score, f1_score, confusion_matrix
import seaborn as sns
from torchvision.models import resnet50, ResNet50_Weights

# Cek apakah kode dijalankan di Google Colab
IN_COLAB = 'google.colab' in str(get_ipython())

# Cek apakah GPU tersedia, jika tidak gunakan CPU
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(f'Using device: {device}')

# Mount Google Drive jika menggunakan Google Colab
if IN_COLAB:
    from google.colab import drive
    drive.mount('/content/drive')

"""# Cell 2: Define Data Loading and Preprocessing Functions
'''
This cell contains functions to load and preprocess images from the dataset.
The `load_data` function loads images from the specified directory and assigns labels based on the folder structure.
The `preprocess_image` function applies CLAHE and unsharp masking to enhance image quality.
The `CustomDataset` class integrates these functions and prepares the dataset for use in PyTorch.
'''
"""

def load_data(dataset_path, subset):
    images = []
    labels = []

    # Tentukan label sesuai dengan subset

    label_names = ['adenocarcinoma', 'large.cell.carcinoma', 'normal', 'squamous.cell.carcinoma']



    # Pemetaan nama label ke indeks
    label_map = {name: idx for idx, name in enumerate(label_names)}

    subset_path = os.path.join(dataset_path, subset)
    for label_name in label_names:
        image_dir = os.path.join(subset_path, label_name)
        if not os.path.exists(image_dir):
            raise FileNotFoundError(f"Directory not found: {image_dir}")
        for file_name in os.listdir(image_dir):
            if file_name.endswith('.png'):  # Cek jika file adalah gambar PNG
                image_path = os.path.join(image_dir, file_name)
                image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
                if image is None:
                    print(f"Warning: Unable to load image {image_path}")
                    continue
                images.append(image)
                labels.append(label_map[label_name])
                print(f"Loaded image {image_path}")
    return images, labels
def preprocess_image(image):
    if image is None or image.size == 0:
        raise ValueError("Empty image provided for preprocessing")

    # Terapkan CLAHE untuk meningkatkan kontras
    #clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    clahe = cv2.createCLAHE(clipLimit=2.5, tileGridSize=(10, 10))

    clahe_image = clahe.apply(image)

    # Terapkan Gaussian Blur untuk menghaluskan gambar
    #gaussian = cv2.GaussianBlur(image, (9, 9), 10.0)
    # Terapkan Unsharp Masking untuk meningkatkan ketajaman gambar
    #unsharp_image = cv2.addWeighted(clahe_image, 1.5, gaussian, -0.5, 0, clahe_image)
    #unsharp_image = cv2.addWeighted(gaussian, 1.5, gaussian, -0.5, 0)

    return clahe_image

class CustomDataset(Dataset):
    def __init__(self, images, labels, transform=None):
        self.images = images
        self.labels = labels
        self.transform = transform

    def __len__(self):
        return len(self.images)

    def __getitem__(self, idx):
        image = self.images[idx]
        label = self.labels[idx]

        # Terapkan transformasi jika ada
        if self.transform:
            image = self.transform(image)
        if image.dim() == 2:  # Pastikan gambar memiliki 3 dimensi
            image = image.unsqueeze(0)
        return image, label

"""# Cell 3: Load and Transform Data
'''
This cell loads the data and applies the necessary transformations.
The dataset is divided into training, validation, and test sets.
Each image is transformed into a 224x224 size tensor suitable for input to the VGG-16 model.
'''
"""

# Mengatur path dataset, disesuaikan untuk Google Colab atau Jupyter Notebook
dataset_path = '/content/drive/MyDrive/Chest-CT-Data'

# Load data
train_images, train_labels = load_data(dataset_path, 'train')
valid_images, valid_labels = load_data(dataset_path, 'valid')
test_images, test_labels = load_data(dataset_path, 'test')

print(f"Loaded {len(train_images)} training images with {len(train_labels)} labels")
print(f"Loaded {len(valid_images)} validation images with {len(valid_labels)} labels")
print(f"Loaded {len(test_images)} test images with {len(test_labels)} labels")

# Transformasi data untuk persiapan training, validation, dan testing
transform = transforms.Compose([
    transforms.ToPILImage(),             # Ubah dari array NumPy ke gambar PIL
    transforms.Resize((224, 224)),       # Ubah ukuran gambar menjadi 224x224
    #v2.RandomHorizontalFlip(),           # Randomly flip the image horizontally
   # v2.RandomRotation(15),                # Randomly rotate the image by up to 15 degrees
    transforms.ToTensor(),               # Ubah gambar menjadi Tensor and normalize to [0, 1]
])

# Membuat dataset dan data loader untuk training, validation, dan testing
train_dataset = CustomDataset(train_images, train_labels, transform=transform)
valid_dataset = CustomDataset(valid_images, valid_labels, transform=transform)
test_dataset = CustomDataset(test_images, test_labels, transform=transform)

train_loader = DataLoader(train_dataset, batch_size=8, shuffle=True)  # DataLoader untuk training
valid_loader = DataLoader(valid_dataset, batch_size=8, shuffle=False) # DataLoader untuk validasi
test_loader = DataLoader(test_dataset, batch_size=8, shuffle=False)   # DataLoader untuk testing

"""# Cell 4: Load Model and Pruning
'''
This cell loads the pre-trained VGG-16 model and applies pruning to its convolutional layers.
Pruning is used to reduce the size of the model by setting certain weights to zero, based on a threshold.
'''
"""

# Load ResNet pretrained tanpa classifier (hanya sebagai feature extractor)
resnet_model = models.resnet50(weights=ResNet50_Weights.IMAGENET1K_V1)
#Resnet_features = nn.Sequential(*list(resnet_model.children()))  # Ambil bagian feature extractor

# Ambil bagian feature extractor (semua layer kecuali fully connected)
Resnet_features = nn.Sequential(*list(resnet_model.children())[:-1])  # Keluarkan layer fully connected atau layer klasifikasi

#num_ftrs = resnet_model.fc.in_features   # No. of input features to fully connected layer

# Freeze semua parameter di feature extractor
#for param in Resnet_features.parameters():
#    param.requires_grad = False

# Custom Model dengan ResNet50 feature extractor + Fully Connected Layers untuk klasifikasi
class CustomResNet50Classifier(nn.Module):
    def __init__(self, num_classes):
        super(CustomResNet50Classifier, self).__init__()
        # Feature extractor dari ResNet50
        self.features = Resnet_features
        #self.global_avg_pool = nn.AdaptiveAvgPool2d((1, 1))  # Global average pooling

        # Fully connected layers untuk klasifikasi
        self.classifier = nn.Sequential(
            nn.Flatten(),
            nn.Linear(2048, 512),  # Sesuaikan input sesuai dengan output dari feature extractor ResNet50
            nn.ReLU(),
            nn.Dropout(0.4),
            nn.Linear(512, num_classes)
        )

    def forward(self, x):
        # Ekstraksi fitur
        x = self.features(x)
        x = self.classifier(x)  # Klasifikasi
        return x

# Jumlah kelas untuk klasifikasi
num_classes = 4

# Inisialisasi model
model = CustomResNet50Classifier(num_classes)

# Pindahkan model ke GPU jika tersedia, jika tidak gunakan CPU
model = model.to(device)

"""Penjelasan Kode:
Penambahan Fully Connected Layer:

nn.Linear(512 * 7 * 7, 1024) → Menghubungkan output dari feature extractor (25088 neuron) ke layer fully connected pertama dengan 1024 neuron.
nn.Linear(1024, 512) → Layer fully connected tambahan yang mengambil input dari layer sebelumnya dan mengubahnya menjadi 512 neuron.
nn.Linear(512, num_classes) → Layer fully connected terakhir untuk output ke jumlah kelas sesuai tugas klasifikasi (misalnya 4 kelas).

# Mengetahui Ukuran Model
"""

print(Resnet_features)

# Cek model
print(model)

pip install torchinfo

from torchinfo import summary
summary(model)

# # Do a summary *after* freezing the features and changing the output classifier layer (uncomment for actual output)
summary(model,
        input_size=(16, 3, 224, 224), # make sure this is "input_size", not "input_shape" (batch_size, color_channels, height, width)
        verbose=0,
        col_names=["input_size", "output_size", "num_params", "trainable"],
        col_width=20,
        row_settings=["var_names"]
)

"""# Cell 5: Training Loop with Checkpointing
'''
This cell implements the training loop with checkpointing.
Checkpointing allows you to save the model's state after each epoch, so you can resume training later if needed.
The best model (based on validation loss) is also saved separately.
'''
"""

# Fungsi untuk menyimpan checkpoint
def save_checkpoint(state, filename='checkpoint.pth.tar'):
    torch.save(state, filename)
    print(f"Checkpoint saved at {filename}")

# Fungsi untuk memuat checkpoint
def load_checkpoint(filename):
    checkpoint = torch.load(filename)
    model.load_state_dict(checkpoint['state_dict'])
    optimizer.load_state_dict(checkpoint['optimizer'])
    start_epoch = checkpoint['epoch'] + 1
    train_losses = checkpoint['train_losses']
    valid_losses = checkpoint['valid_losses']
    print(f"Checkpoint loaded from {filename}, starting at epoch {start_epoch}")
    return start_epoch, train_losses, valid_losses

# Optimizer dan fungsi loss
# Definisikan optimizer dengan L2 regularization (weight decay)
optimizer = optim.SGD(model.parameters(), lr=0.001, momentum = 0.9)
criterion = nn.CrossEntropyLoss()

# Variables to track time
total_training_time = 0
total_testing_time = 0

# Training loop with checkpoint, metrics, and timing
num_epochs = 70
best_valid_loss = float('inf')
train_losses = []
valid_losses = []
train_accuracies = []
valid_accuracies = []

start_epoch = 0
checkpoint_file = 'checkpoint.pth.tar'
if os.path.exists(checkpoint_file):
    start_epoch, train_losses, valid_losses = load_checkpoint(checkpoint_file)

# Start total training time
training_start_time = time.time()

for epoch in range(start_epoch, num_epochs):
    epoch_start_time = time.time()  # Start time for each epoch

    model.train()
    train_loss = 0
    true_labels_train = []
    predicted_labels_train = []

    train_loader_tqdm = tqdm(train_loader, desc=f"Epoch {epoch+1}/{num_epochs} - Training")
    for images, labels in train_loader_tqdm:
        images, labels = images.to(device), labels.to(device)
        if images.dim() == 3:
            images = images.unsqueeze(1)
        images = images.repeat(1, 3, 1, 1)

        outputs = model(images)
        loss = criterion(outputs, labels)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        train_loss += loss.item()

        # Collect labels for metrics calculation
        predicted_labels_train.append(torch.argmax(outputs, dim=1))
        true_labels_train.append(labels)

        train_loader_tqdm.set_postfix({"Loss": loss.item()})

    train_loss /= len(train_loader)
    train_losses.append(train_loss)

    # Combine all predicted and true labels
    predicted_labels_train = torch.cat(predicted_labels_train)
    true_labels_train = torch.cat(true_labels_train)

    # Calculate metrics for training data
    train_accuracy = (predicted_labels_train == true_labels_train).float().mean().item()
    train_precision = precision_score(true_labels_train.cpu(), predicted_labels_train.cpu(), average='weighted', zero_division=1)
    train_recall = recall_score(true_labels_train.cpu(), predicted_labels_train.cpu(), average='weighted', zero_division=1)
    train_f1 = f1_score(true_labels_train.cpu(), predicted_labels_train.cpu(), average='weighted', zero_division=1)

    train_accuracies.append(train_accuracy)

    print(f'Epoch [{epoch+1}/{num_epochs}], Train Loss: {train_loss:.4f}, Accuracy: {train_accuracy:.4f}, Precision: {train_precision:.4f}, Recall: {train_recall:.4f}, F1-Score: {train_f1:.4f}')

    # Validation
    valid_loss = 0
    model.eval()
    true_labels_valid = []
    predicted_labels_valid = []

    valid_loader_tqdm = tqdm(valid_loader, desc=f"Epoch {epoch+1}/{num_epochs} - Validation")
    with torch.no_grad():
        for images, labels in valid_loader_tqdm:
            images, labels = images.to(device), labels.to(device)
            if images.dim() == 3:
                images = images.unsqueeze(1)
            images = images.repeat(1, 3, 1, 1)
            outputs = model(images)
            loss = criterion(outputs, labels)
            valid_loss += loss.item()

            # Collect labels for metrics calculation
            predicted_labels_valid.append(torch.argmax(outputs, dim=1))
            true_labels_valid.append(labels)

            valid_loader_tqdm.set_postfix({"Loss": loss.item()})

    valid_loss /= len(valid_loader)
    valid_losses.append(valid_loss)

    # Combine all predicted and true labels
    predicted_labels_valid = torch.cat(predicted_labels_valid)
    true_labels_valid = torch.cat(true_labels_valid)

    # Calculate metrics for validation data
    valid_accuracy = (predicted_labels_valid == true_labels_valid).float().mean().item()
    valid_precision = precision_score(true_labels_valid.cpu(), predicted_labels_valid.cpu(), average='weighted', zero_division=1)
    valid_recall = recall_score(true_labels_valid.cpu(), predicted_labels_valid.cpu(), average='weighted', zero_division=1)
    valid_f1 = f1_score(true_labels_valid.cpu(), predicted_labels_valid.cpu(), average='weighted', zero_division=1)

    valid_accuracies.append(valid_accuracy)

    print(f'Validation Loss: {valid_loss:.4f}, Accuracy: {valid_accuracy:.4f}, Precision: {valid_precision:.4f}, Recall: {valid_recall:.4f}, F1-Score: {valid_f1:.4f}')



    # Save the best model
    if valid_loss < best_valid_loss:
        best_valid_loss = valid_loss
        torch.save(model.state_dict(), 'best-model-resnet-clahe-0,001-8-70.pth')

    # Save checkpoint every epoch
    checkpoint = {
        'epoch': epoch,
        'state_dict': model.state_dict(),
        'optimizer': optimizer.state_dict(),
        'train_losses': train_losses,
        'valid_losses': valid_losses,
    }
    save_checkpoint(checkpoint, checkpoint_file)

    # Calculate epoch time and add to total training time
    epoch_time = time.time() - epoch_start_time
    total_training_time += epoch_time
    print(f"Epoch [{epoch+1}/{num_epochs}] completed in {epoch_time:.2f} seconds")

# End total training time
total_training_time = time.time() - training_start_time
print(f"Total training time: {total_training_time:.2f} seconds")

# Plot training and validation loss
plt.figure(figsize=(10, 5))
plt.plot(train_losses, label='Training Loss')
plt.plot(valid_losses, label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.title('Training and Validation Loss')
plt.show()

# Plot training and validation accuracy
plt.figure(figsize=(10, 5))
plt.plot(train_accuracies, label='Training Accuracy')
plt.plot(valid_accuracies, label='Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()
plt.title('Training and Validation Accuracy')
plt.show()

# Hitung rata-rata metrik setelah semua epoch
average_train_loss = np.mean(train_losses)
average_valid_loss = np.mean(valid_losses)
average_train_accuracy = np.mean(train_accuracies)
average_valid_accuracy = np.mean(valid_accuracies)
average_train_precision = np.mean(train_precision)
average_valid_precision = np.mean(valid_precision)
average_train_recall = np.mean(train_recall)
average_valid_recall = np.mean(valid_recall)
average_train_f1 = np.mean(train_f1)
average_valid_f1 = np.mean(valid_f1)


# Display results training
print('--------------')
print(f'Training Accuracy: {average_train_accuracy * 100:.2f}%')
print(f'Training Loss: {average_train_loss:.4f}')
print(f'Training Precision: {average_train_precision:.4f}')
print(f'Training Recall: {average_train_recall:.4f}')
print(f'Training F1-Score: {average_train_f1:.4f}')


# Display results validasi
print('--------------')
print(f'Validation Accuracy: {average_valid_accuracy * 100:.2f}%')
print(f'Validation Loss: {average_valid_loss:.4f}')
print(f'Validation Precision: {average_valid_precision:.4f}')
print(f'Validation Recall: {average_valid_recall:.4f}')
print(f'Validation F1-Score: {average_valid_f1:.4f}')

"""# Cell 6: Model Evaluation with Additional Metrics
'''
This cell evaluates the best model using accuracy, precision, recall, F1-score, and confusion matrix.
These metrics provide a comprehensive understanding of the model's performance on the test dataset.
'''
"""

# Path dinamis untuk memuat model terbaik
best_model_file = '/content/drive/MyDrive/Chest-CT-Data/best-model-resnet-clahe-0,001-8-70.pth' if IN_COLAB else 'best-model.pth'
# Start testing time
testing_start_time = time.time()

# Load the best model
model.load_state_dict(torch.load('best-model-resnet-clahe-0,001-8-70.pth'))
model.eval()

# Define class labels corresponding to the numerical labels
class_labels = [
    'Adenocarcinoma',
    'Large Cell Carcinoma',
    'Normal',
    'Squamous Cell Carcinoma'
]

predicted_probabilities = []
true_labels = []

test_loader_tqdm = tqdm(test_loader, desc="Testing")
with torch.no_grad():
    for images, labels in test_loader_tqdm:
        images, labels = images.to(device), labels.to(device)
        if images.dim() == 3:
            images = images.unsqueeze(1)
        images = images.repeat(1, 3, 1, 1)
        outputs = model(images)
        probabilities = nn.functional.softmax(outputs, dim=1)
        predicted_probabilities.append(probabilities)
        true_labels.append(labels)
        test_loader_tqdm.set_postfix({"Batch Size": len(labels)})

# End testing time
total_testing_time = time.time() - testing_start_time
print(f"Total testing time: {total_testing_time:.2f} seconds")

# Calculate evaluation metrics
predicted_probabilities = torch.cat(predicted_probabilities)
true_labels = torch.cat(true_labels)
predicted_labels = torch.argmax(predicted_probabilities, dim=1)

accuracy = (predicted_labels == true_labels).float().mean().item()
precision = precision_score(true_labels.cpu(), predicted_labels.cpu(), average='weighted')
recall = recall_score(true_labels.cpu(), predicted_labels.cpu(), average='weighted')
f1 = f1_score(true_labels.cpu(), predicted_labels.cpu(), average='weighted')
conf_matrix = confusion_matrix(true_labels.cpu(), predicted_labels.cpu())

# Display results
print(f'Test Accuracy: {accuracy * 100:.2f}%')
print(f'Test Loss: {loss:.4f}')
print(f'Precision: {precision:.4f}')
print(f'Recall: {recall:.4f}')
print(f'F1-Score: {f1:.4f}')
print(f'Confusion Matrix:\n{conf_matrix}')

# Plot confusion matrix using Matplotlib
fig, ax = plt.subplots(figsize=(12, 9))
cax = ax.matshow(conf_matrix, cmap='Blues')

# Menampilkan angka pada setiap sel dengan outline putih
for (i, j), val in np.ndenumerate(conf_matrix):
    text = ax.text(j, i, f'{val}', ha='center', va='center', color='black', fontsize=20, fontweight='bold')

    # Menambahkan outline putih di sekitar angka
    text.set_path_effects([path_effects.Stroke(linewidth=3, foreground='white'),
                           path_effects.Normal()])

fig.colorbar(cax)

# Set ticks dan ticklabels
ax.set_xticks(np.arange(len(class_labels)))
ax.set_yticks(np.arange(len(class_labels)))
ax.set_xticklabels(class_labels)
ax.set_yticklabels(class_labels)

plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.title('Confusion Matrix')
plt.show()


# Total time for the whole process
total_process_time = total_training_time + total_testing_time
print(f"Total process time (training + testing): {total_process_time:.2f} seconds")

"""![image.png](data:image/png;base64,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)"""

